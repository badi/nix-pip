* Status

  Under development, *unstable*

* Goal

  Automatically and painlessly (as possible) derive Nix package sets
  for python dependencies.

* Usage

  - =pip2nix= generates the Nix expressions from the current loaded python environment
  - =pip2nix -r requirements.txt= uses the requirements specified in the given file
  - =pip2nix -p foo -p bar= will generate requirement sets to allow
    installation of packages =foo= and =bar=
  - =pip2nix -p foo -s cryptography packaging -i cryptography openssl
    -i cffi libffi= This generates derivations for =foo= and it's
    dependencies. Two of the depencencies are =cryptography= and
    =cffi= which respectively depend on =openssl= and =libffi=.

  This will generate =requirements.nix=

* Assumptions

  This is intended to be used for projects which can already be
  installed using =pip=.

* Requirements

  - Python
    See [[file:requirements.lock][requirements.lock]] and [[file:requirements.open][requirements.open]] for the python
  - Nix+Nixpkgs
    A version of nixpkgs *after* 2017-02-17 is required due to the use of =fetchPyPI=.
    See [[file:nixpkgs.nix][nixpkgs.nix]]

* Procedure

** Identify packages in fresh virtualenv

   Generate an empty virtualenv to determine which packages will be
   preinstalled. This is usually =pip=, =setuptools=, =wheel=,
   etc. These packages are then subtracted from those identified as
   dependencies for a given package.

** Generate frozen requirements

   =pip freeze= to generate a frozen requirements set.

** Parsing of requirements

   Map over the frozen set to generate an initial list of
   dependencies. Information collected for each package are:

   - name
   - version

   This produces a mapping from =name-version= to a =PackageEntry=

** Start building dependency graph

   Process each entry from *By calling

   #+BEGIN_SRC shell
   pip download --isolated -d <workdir> <name>==<version>
   #+END_SRC

   Ensure that all the dependencies downloaded by =pip= are mapping of =PackageEntry=\s.
   Add each dependency set to the =PackageEntry= being processed.

** Verify dependencies from PyPI API

   PyPI provides an API yielding JSON for each package at:

   #+BEGIN_EXAMPLE
   https://pypi.python.org/pypi/<package-name>/json
   #+END_EXAMPLE

   See [[https://wiki.python.org/moin/PyPIJSON][PyPIJSON]] and [[https://www.python.org/dev/peps/pep-0386/][PEP 386]] for details on the protocol

   This can be queried and the resultant =.info= may have a
   =requires_dist= attribute.

   An example from the =azure= package:

   #+BEGIN_EXAMPLE
     $ http --print=b https://pypi.python.org/pypi/azure/json | jq .info.requires_dist
     [
       "azure-batch (==1.0.0)",
       "azure-mgmt (==0.30.0rc6)",
       "azure-servicebus (==0.20.3)",
       "azure-servicemanagement-legacy (==0.20.4)",
       "azure-storage (==0.33.0)"
     ]
   #+END_EXAMPLE

   This should be used to update the dependencies for each =PackageEntry=.

   # This step also fixes the name of packages that may have been
   # incorrectly identified. For instance, the *filename* for the
   # =azure-batch= *package* is =azure_batch-...=.

** Determine URLs

   The PyPI API also provides =.releases= (mapping from version to list of release info).
   This include the url to download each source package. Relevant fields are:

   - =package_type=: "sdist" or "bdist_wheel"
   - =python_version=: eg "source" or "py2.py3"
   - =filename=: the basename
   - =url=: full url to retrieve

   When downloading prefer universal wheels when available.
   Universal wheel filenames have the format like =name-version-python-abi-platform.whl=

   #+BEGIN_EXAMPLE
   entrypoints=0.2.1-py2.py3-none-any.whl
   #+END_EXAMPLE

   If no universal wheel is found, a source distribution can be used.

** Download each url and determine sha256

** Verify build of each source distribution

   For each source-based =PackageEntry=, verify that the deduced
   dependency set is accurate by attempting to install into a fresh
   virtualenv. Use the =--no-deps= flag for =pip install=

   1. create virtualenv
   2. install dependencies using =pip install --no-deps=
   3. install the package using =pip install --no-deps=

   If there is a build error, parse the output to determine the
   missing packages and add them to the dependency set and retry.


** Generate =requirements.nix=
